# Refactoring


<hr/>

## 기본적인 리팩토링

### 함수 추출하기
- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다. 
- 목적과 구현을 분리하는 방식을 기준으로 잡으면 좋다
  - 코드를 보고 무슨 동작을 하는지 파악하는데 시간이 한참 걸린다면 그 부분을 함수로 추출한 뒤 `무슨일`에 걸 맞는 이름을 지어주는 것이 좋다.
    - 이러한 방식을 사용하면 코드가 길어질 수는 있지만, 함수의 목적이 눈에 명확하게 들어온다.
    - 함수 안에 들어갈 코드가 `대 여섯줄을 넘어`갈 떄부터 함수 추출하기를 고려해 보자
      - 저자의 경우 `단 한줄`짜리 메서드를 만드는 경우도 적지 않았다 하였다.
        - ex) 화면의 색을 바꾸는 기능을 하는 메서드의 명이 `highlight()`이지만 내부 코드는 `reverse()`뿐이 었다.
          - 메서드 명보다 내부 실행 함수가 더 짧지만 단 한줄의 메서드로 추출함으로 써 조금 더 직관적으로 변함
          - 단! 위와 같은 경우는 `메서드명`을 잘 짓는것이 가장 중요하다.
- 절차 
  - 1 . 함수를 새로 만들고 목적이 잘들어나는  `이름`을 붙인다. (어떻게가 아닌 '무엇을' 하는지)
    -  처음부터 최선의 이림을 짓고 시작할 필요는 없다.
    - 일단 함수로 추출해서 사용해보고 효과가 크지 않다면 다시 원래 상태로 인라인 시켜도 괜찮다.
      - 이 과정이 시간낭비라 생각할 수 있지만 꺠달은게 있다면 시간낭비가 아니다.
    - 중첩 함수를 지원하는 언어를 사용한다면 추출한 함수를 함수안에 중첩 시키자 
      - 다음 단계에서 수행할 유효 범위를 벗어난 변수를 처리하는 작업을 줄일 수 있다.
  - 2 . 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
  - 3 . 추출한 코드중 원본 함수의 지역 변수를 참조하거나 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. (있다면 매개변수로 전달)
    - 추출한 코드에서만 사용하는 변수가 추출한 함수 밖에 선언되어 있다면 추출한 함수 안에서 선언하도록 수정해 주자.
    - 추출한 코드에서 값을 수정하는 지역 변수가 너무 많을 경우 `함수 추출`을 멈추고 `변수 쪼개기`나 `임시 변수를 질의 함수로 변경`하기 와 같은 다른 리팩토링을 적용하여  
   코드를 단순화 한 후 함수 추출하기를 다시 시도하는 것이 좋다.
  - 4 . 변수 처리가 끝났다면 컴파일을 한다.
    - 컴파일을 통해 제대로 처리 하지 못한 변수를 찾는데 도움이 될 수 있다.
  - 5 . 원본 함수에서 추출한 코드 부분을 `새로 만든 추출한 함수`로 변경 해준다.
  - 6 . 테스트 코드를 작성하여 테스트를 진행한다.
  - 7 . 방금 추출하여 만든 코드와 비슷하거나 똑같은 코드가 없는지 확인한다. -> 있다면 방금 추출한 함수를 호출하도록 바꿀지 검토한다.
- 예시
  - 유효 범위를 벗어나는 변수가 없을 때 : [링크](https://github.com/edel1212/refactoring/blob/main/refactoringSkills/extaractFunction/ex01.js)
    - 중첩 함수를 통해 해결함
  - 지역 변수를 사용할 때 : [링크](https://github.com/edel1212/refactoring/blob/main/refactoringSkills/extaractFunction/ex02.js)
    - 추출한 함수에 매개변수로 지역변수를 전달하여 해결함
  - 지역 변수의 값을 변경 할 때 : [링크](https://github.com/edel1212/refactoring/blob/main/refactoringSkills/extaractFunction/ex03.js)
    - 함수를 추출 후 반환 값이 있는 `return`하는 함수로 만든 후 지역변수에 해당 값을 할당하여 해결함
    - **값을 반환할 변수가 여러개 일 경우 ?**
      - 각각 반환환하는 함수를 여러개로 만드는 방법
      - 반환 값들을 한 레코드로 묶어서 반환해도 되지만 이러한 방법 보다는 `임시 변수를 질의함수로 바꾸기` 혹은 `변수를 쪼개기`를 사용하여 쪼개서 보내주는 것이 좋다.


### 함수 인라인하기
- 해당 리팩토링 기법 반대의 기법은 위에서 설명했던 `함수 추출하기`이다.
- 해당 책에서는 분명 목적이 들어나는 이름으로 함수를 추출하라고 권하였지만, 때때로 함수 본문이 이름만큼 명확한 경우에는 오히려 그 함수를 `제거` 한다.
  - 간접 호출은 유용할 할 수 있지만 쓸데 없는 간접 호출은 거슬릴 뿐이기 떄문이다.
- ✅ 배워야하는 중요 포인트는 언제 `함수 추출하기` 또는 `함수 인라인하기`를 사용할지 정하는 방법이다. 
- 간접 호출을 너무 과하게 쓰는 코드 또는 위임 관계가 복잡하게 얽혀 있으면 `함수 인라인`의 대상이다.
- 재귀호출, 반환문이 여러개인 함수, 접근자가 없이 다른 메서드를 인하인 함수 와 같은 복잡한 함수는 `인라인하기를 적용하면 안되는` 함수라고 판단하자.
- 절차
  - 1 . 다형성 메서드인지 확인한다.
    - 서브클래스에서 오버라이드하는 메서드는 인라인 하기가 `불가능`하기 때문이다.
  - 2 . 인라인할 함수를 호출하는 곳을 모두 찾는다.
  - 3 . 각 호출문을 함수 본문으로 교체해 준다.
  - 4 . 하나씩 교체할 때마다 테스트 해준다.
    - 한번에 처리할 필요가 없다, 인라인하기 까다로운 부분이 있다면 일단 남겨두고 여유가 생실떄마다 변경해줘도 괜찮다.
  - 5 . 모든 교체가 끝난다면 원래 정의 되어 있는 함수를 삭제한다.
- 예시
  - 함수로 추출되어 있지만 코드의 내용이 직관적인 상황 : 


<hr/>



## 리팩토링이 필요한 순간

### 기이한 이름
- 코드는 단순하고 명료하게 작성해야한다.
- 코드를 명료하게 표한하는데 가장 중요한 요소는 바로 `이름`이다.
- 이름만 잘 지어도 문백을 파악하느라 헤매는 시간을 크게 절약 할 수 있다.

### 중복 코드
- 똑같은 코드 구조가 여러 곳에서 번복 된다면 하나로 통합혀야 더 나은 프로그램을 만들 수 있다
  - 같은 코드가 3번 이상 반복 되면 그 코드는 하나의 메서드로 만들어 사용해주자
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸자
- 코드가 비슷하긴 한데 완전히 똑같지 않다면 `문장 슬라이드하기`로 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 확인해 보자

### 긴 함수
- 오랜 기간 잘 활용돠는 프로그램들의 코드 들은 하나 같이 `짧은 함수`로 구성되어 있다.
  - 내부 로직에는 연산하는 부분이 하나도 없어 보인다.
    - 코드가 끝 없이 위임 하는 방시긍로 작성되어 있기 떄문이다.
- `간접 호출의 효과` : 코드를 이해, 공유, 선택하기 쉬워진다는 장접은 장점은 함수를 짧게 구성할 떄 나오는 것이다.
- 여기서도 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 쉽고 확실한 방법은 `이름을 잘 지어두기`이다.
  - 함수 이름은 동장 방식이 아닌 `의도`가 잘들어나게 지어야한다.
- 원래 코드보다 길어지도라도 함수 단위로 `쪼개`어서 구현 후 의도에 맞게 이름을 지어 주자.
- 함수를 짧게 만드는 작업의 99%는 `함수 추출하기`이다.
  - 함수 본문에서 따로 묶어서 뺴낼 수 있는 코드 덩어리를 찾아 `새로운 함수를 만드`는 것이다.
- 리팩토링 대상의 함수가 매개변수와 임시 변수를 많이 사용한다면 함수를 추출하는데 어려울 수 있는데 이럴 땐 `매개변수를 객체로 만들기` 와 `그 객체 통쨰로 넘기기`를 사용하자
- 추출할 코드 덩어리 찾는 방법은?
  - 주석을 위주로 찾자 `주석이 달려있는 코드는` 코드만으로 이해하기 어렵기에 달려있을 확률이 높기 떄문이다.
    - 주석을 기준으로 만들어진 메서드의 경우 메서드 명은 주석명을 기반으로 작성해주자.
    - 코드가 단 한줄일 경우에도 설명할 필요가 있다면 함수로 추출하는 게 좋다.
  - 조건문이나 반복문의 경우에도 사용할 수 있다.
    - switch문
      - 거대한 switch의 경우 case문 마다 `함수를 추출`을 적용해서 각 case의 본문을 함수 호출문 하나로 변경 한다.
      - 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 `조건부 로직을 다형성`으로 바꿔주자.
    - 반복문
      - 반복문 내부의 로직이 길어 진다면 독립된 함수로 추출하여 생성한다.


### 긴 매개변수 목록
- 매개변수 목록이 길어지면 그 자체로 이해하가 어려우므로 리팰토링 해줄 필요가 있다.
- 다른 매개 변수에서 값을 얻어 와야하는 매개 변수가 있는데 이런 경우 `매개변수를 질의 함수 바꾸기`로 제거 할 수 있다.
```javscript
// 👎 원래 코드
class ComedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 30000;
    if (this.performance.audience > 20) {
      result += 10000 + 500 * (this.performance.audience - 20);
    }
    result += 300 * this.performance.audience;
    return result;
  }
}

/*************************************************************************************/
/*************************************************************************************/

// 👍 매개변수를 질의 함수로 바꿈 
class ComedyCalculator extends PerformanceCalculator {
  get amount() {
    return 30000 + this.bonusAmount;
  }

  get bonusAmount() {
    return this.overThresholdAmount + this.perAudienceAmount;
  }

  get overThresholdAmount() {
   // 👉 if (this.performance.audience > 20) 대체 가능 이유는 20 보다 큰지 확인 하는 것이기 떄문 생각해보면 당연한것 !
    return Math.max(this.performance.audience - 20, 0) * 500;
  }

  get perAudienceAmount() {
    return 300 * this.performance.audience;
  }
}
```
- 사용 중인 데이터 구조에서 값들을 뽑아서 각가의 별개의 매개변수를 전달하는 코드라면 `객체 통째로 넘기기`를 적용해서 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들의 그룹이 있다면 해댕 목록의 변수들을 `매개변수 객체 만들기`를 사용해주자
- 함수의 동장 방식을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애준다.
  - 코드를 이해하기 어려워지기 때문 이럴 경우 메서드를 `2개로 나눠서` 사용해주는것이 더욱 가독성이 높디.
```javascript
// 👎 원래 코드
function calculateTotal(amount, applyDiscount) {
  if (applyDiscount) {
    // 할인을 적용하는 로직
    return amount * 0.9;
  } else {
    return amount;
  }
}
        
/*************************************************************************************/
/*************************************************************************************/

// 👍 메서드를 분리함
function calculateTotalWithoutDiscount(amount) {
  return amount;
}

function calculateTotalWithDiscount(amount) {
  return amount * 0.9;
}
```
- 클래스를 활용 하는 것도 매개변수 목록을 줄이는데 효적인 수단이다.
  - 여러 개의 함수가 특정 매개변수들의 값을 공통적으로 사용할 경우 `여러 함수를 클래스로 묶어` 사용해 주자.
```javascript
// 👎 원래 코드
function calculateTotalWithDiscount(amount, applyDiscount) {
  let total = amount;
  if (applyDiscount) {
    total *= 0.9;
  }
  return total;
}

function calculateTax(amount, taxRate) {
  return amount * (taxRate / 100);
}

function calculateFinalPrice(amount, applyDiscount, taxRate) {
  const total = calculateTotalWithDiscount(amount, applyDiscount);
  const tax = calculateTax(total, taxRate);
  return total + tax;
}
        
/*************************************************************************************/
/*************************************************************************************/

// 👍 PricingCalculator 클래스로 묶어 생성자들 통해 주입 받아 사용함
class PricingCalculator {
  constructor(amount, applyDiscount, taxRate) {
    this.amount = amount;
    this.applyDiscount = applyDiscount;
    this.taxRate = taxRate;
  }

  calculateTotalWithDiscount() {
    let total = this.amount;
    if (this.applyDiscount) {
      total *= 0.9;
    }
    return total;
  }

  calculateTax() {
    return this.amount * (this.taxRate / 100);
  }

  calculateFinalPrice() {
    const total = this.calculateTotalWithDiscount();
    const tax = this.calculateTax();
    return total + tax;
  }
}
```

### 전역 데이터
- 전역 데이터는 악취 중에 `가장 독한` 축에 속한다.
  - 코드 내 어디서든 건들일 수 있고 값을 누가 바꿨는지 찾아 낼 방법이 없기 떄문이다.
  - 버그가 끊임 없이 발생할 확률이 높은데 그 원인을 찾아내기가 굉장히 어렵다.
- 대표적인 리퍅토링 방법은 `변수 캡슐화하기`이다.
```javascript
// 👎 원래 코드
let globalCounter = 0;

function incrementCounter() {
  globalCounter++;
}

function getCounter() {
  return globalCounter;
}
        
/*************************************************************************************/
/*************************************************************************************/

// 👍 전역 변수를 캡슐화 시킴
class Counter {
  constructor() {
    this.globalCounter = 0; // 앞에 _를 붙여서 내부 변수임을 나타냅니다.
  }

  increment() {
    this.globalCounter++;
  }

  getCount() {
    return this.globalCounter;
  }
}
```

### 가변 데이터
- 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식 하지 못한 채 수정하여 프로그램 오작동 하며 이러한 문제가 아주 드문 조건에서 발생한다면 원인을 찾아내는 것이 매우 어렵다.
- 데이터를 변경하려면 반드시 원래 데이터는 그대로 둔채 변경하려는 값에 해당하는 `복사본을 만들어서 반환` 하는 것을 습관화 하자
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법
  - `변수 캡슐화하기`를 적용허여 정해 놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정 되는지 감시하거나 코드를 개선하기 쉬움. (브레이크포인트를 활용)
  - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우 `변수 쪼개기`를 이용하여 용도별로 독딜 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
     ```javascipt
     // 👎 원래 코드
     function calculateEmployeeSalary(employee) {
       let baseSalary = employee.baseSalary;
       if (employee.isManager) {
          baseSalary += 1000;
       }
       if (employee.hasOvertime) {
         baseSalary += 500;
       }
         return baseSalary;
     }
    
     /*************************************************************************************/
     /*************************************************************************************/
 
     // 👍 전역 변수를 캡슐화 시킴
     function calculateEmployeeSalary(employee) {
        let baseSalary = employee.baseSalary;
        let managerBonus = employee.isManager ? 1000 : 0;
        let overtimeBonus = employee.hasOvertime ? 500 : 0;
        return baseSalary + managerBonus + overtimeBonus;
     }   
     ``` 
  - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋기에 `문장 슬라이드하기` 와 `함수 추출하기`를 이용해서 코드를 분리해주는 것이 좋다.
  - `파생 변수를 질의 함수로 바꾸기`로 변경해서 코드에 적용하기
  - `여러 함수를 클래스로 묶기`로 묶거나 `여러 함수를 변호나 함수로` 묶는 방법을 적용할 수 있다.
  - 내부 필드를 직접 수정하지말고 `참조 값으로 바꾸기`를 적용하여 구조체를 통쨰로 교체하는 편이 더 좋은 방법이다.

### 뒤엉킨 변경
- 소프트웨어의 구조는 변경하기 쉬연 형태로 구성되어야한다.
  - 소프트웨어는 소프트해야 마땅하기 때문이다.
  - 코드를 수정할 떄 `고쳐야할 딱 한군데를 찾아서 수정할 수 있는것`이 좋은 소프트웨어 이다.
- 이렇게 하지 못하는 이유 중 하나는 코드가 `단일 책임 원칙(Single Responsibility Principle)`을 제대로 지키지 않았기 때문이다.
  - 하나의 모듈이 서로 다른 이유로 인해 여러 가지 방식으로 변경되는 일이 많을 떄 발생한다.
- `단계 쪼개기` 와 전체 처리 과정에서 각기 다른 맥륵의 함수를 호출하는 빈도가 높다면 각 `맥락에 해당하는 적당한 모듈을 만들어` 주자.
- 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 `함수로 추출`하여 사용해 주자.

### 산탄총 수술
- 코드를 변경 할때 마다 자잘하게 수정해야 하는 클래스가 너무 많을 때 생기는 문제를 의미한다.
  - 변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야할 곳을 지나칠 활률도 높다.
- 함께 변경되는 대상들을 `함수옮기기` 와 `필드 옮기기`로 모두 한 `모듈`에에 묶어 두면 관리하기가 쉽다.
- 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 `클래스로 묶어`준 후 함수들의 출력 결과를 묶어서 다음 단계의 로직에 전달 할 수있다면 `단계 쪼개기`를 적용해 주자

### 기능 편애
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 `다른 모듈`의 함수나 데이터와 `상호 작용할 일이 더 많을 때` 생기는 문제이다.
- 프로그램을 모듈화 할 때는 영역 `안`에서 이뤄지는 상호작용은 `최대한 늘리고`, 영역 `사이`에서 이뤄지는 상호작용은 `최소로 줄이는데` 주력 하자
- 자주 사용하는 모듈로 해당 기능을 옮겨 주는 방법으로 해결 할 수 있다.
  - 둘다 사용해서 어디로 옮겨야 할지 모를경우 가장 많은 데이터를 포함한 모듈로 옮겨주자
    - `함수 추출하기`로 함수를 여러 조각으로 나눈 후 각각을 접합한 모듈로 옮기면 더 쉽게 해결 할 수 있다.

### 데이터 뭉치
- 몰려다니는 데이터 뭉치는 `클래스` 단위로 묶어서 관리해주자.
  - 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 괜찮다.
  - 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다는 나이진 것이기 때문이다.

### 기본형 집착
- 기본형식에 집착하여 주어진 문제에 맞는기초 타입(화폐,좌표,구간,날짜 등)을 직접 정의하지 않고 기본형을 사용하여 해결하려 하는 문제.
  - 금앨을 그냥 숫자형으로 계산하거나, 물리량을 계산할때 밀리미터나 인치 같은 단위를 뭇시하는 것
- 해당 형식을를 제공해주는 `라이브러리`를 활용하거나 `직접 기능을 하는 Class`를 만들어 적용해 주자.

### 반복되는 switch문
- 같은 조건으로 반복되는 switch문은 다형성을 통해 리팩토링이 가능하다.
```javascipt
// 👎 원래 코드
class Shape {
  constructor(type) {this.type = type;}

  area() {
    switch (this.type) {
      case 'circle':
        return Math.PI * this.radius * this.radius;
      case 'rectangle':
        return this.width * this.height;
      // 등등 .. 
    }// switch
  }// area
}

// 원 class
class Circle extends Shape {
  constructor(radius) {
    super('circle');
    this.radius = radius;
  }// constructor
}

// 직사각형 class
class Rectangle extends Shape {
  constructor(width, height) {
    super('rectangle');
    this.width = width;
    this.height = height;
  } // constructor
}
    
/*************************************************************************************/
/*************************************************************************************/
 
 // 👍 전역 변수를 캡슐화 시킴
class Shape {
  constructor() {}
  area() {}
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}
 ``` 

### 추측성 일반화
- "나중에 필요할 거야"라는 생각으로 당장은 필요 ㅇ벗느 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해 둔 코드를 작성 해 놓는 문제.
- 쓸때 없이 파일의 라인이 길어지며 관리하기 어려워진다.
- 당장 걸리적 거리는 코드는 형상 관리에 남겨 둔 후 삭제해 버리자.

### 임시 필드
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있는데 객체를 가져올때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이기에 해당 파일을 보기 전까지 알수가   
  없다는 단점이 있다.
```javascipt
//  임시 필드 예시
class Order {
  constructor(id) {
    this.id = id;
    this.items = [];
    this.isProcessed = false; // 👉 임시 필드 코드를 열기까지  알 수가 없음 
  }

  addItem(item) {
    this.items.push(item);
  }

  process() {
    // 주문 처리 로직
    this.isProcessed = true;
  }
}
 ```
- 임시 필드는 클래스 추출하기로 위치를 변경해준 후 함수 옮기기로 임시 필드들과 관련도니 코드를 새 클래스로 몰아 넣자.
- `특이 케이스 추가하기`로 필드들이 유효하지 않을 때 위한 대안 클래스를 만들어 주는 방법도 있다.

### 메시지 체인
- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 사용 시 네비게이션 중간 단계를 수정하면 클라이언트의 코드도 수정해야하는 문제가 생길 때가 있다.
  - `managerName = aPerson.departmane.manager.name` -> 중간의 `manager`가 변경 되면 해당 코드를 사용하는 전체를 수정해야함.
    - 이러한 경우 `위임 숨기기` 와 `함수 옮기기`러 함수를 추출하여 객체를 사용하는 코드를 뺴내어서 사용하면 된다.
    ```javascript
    // 👎 변경 전
    managerName = aPerson.department.manager.name;
        
    /*************************************************************************************/
    /*************************************************************************************/
    // 👍 변경 후
    class reportAutoGenerator{
      constructor(aPerson){
        this.aPerson = aPerson;
      }// constructor
    
      report(){return this.aPerson.department.manager.name;}
    } 
    console.log(reportAutoGenerator.report(aPerson));
    ```
    
### 중개자
- 객체의 대표적인 기능중 하나로, 외부로부터 세부사항을 숨겨주는 `캡슐화`가 있다.
- 캡슐화하는 과정에서 `위임이 자주` 활용된다.
  - 클래스가 제공하는 메서드 중 절반이 다른 클래스에  구현을 위임하고 있는 형태의 지나친 위임은 문제가 된다. 이러한 경우 `중개자 제거하기`를 사용하여 리팩토링 해주자.

### 내부자 거래
- 모듈 사이의 데이터 거래가 많으면 결합도가 높아 지므로 그양을 최소로 줄이고 모두 투명하게 처리해야한다.
- 은밀하게 데이터를 주고받는 모듈들이 있다면 `함수 옮기기`와 `필드 옮기기` 기법을 떼어 놓아서 사적으로 처리하는 부분을 줄여 주자.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 `제 3 모듈을 새로 만드거`나 `위임 숨기기`를 이용하여 다른 모듈이 중산자 역할을 하게 만들자.

### 거대한 클래스
- 클래스에 필드가 너무 많으면 중복 코드가 발생하기 쉬우며 유지 및 보수하기가 어려워진다.
- `클래스 추출하기`로 필드들 일부를 따로 묶는다. ==> `추출 한 후 상속 관계로 만드는 것이 좋음 👍 `
  - 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다.
  - 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다.
  - 위와 같은 기준으로 분리할 컴포넌트를 원래 클래스와 `상속 관계`로 만든느 것이 좋다.
    - `슈퍼클래스 추출하기`나 `타입 코드를 서브클래스로 바꾸기`를 적용하는 편이 더욱 관리하기 편하다. 
  - 중복된 코드를 제거하는 것도 좋은 방법이다.
    - 중복된 코드를 작은 메서드로 뽑아내어 적용하자

### 서로 다른 인터페이스의 대안 클래스들
- 클래스를 사용 할때의 큰 장점은 필요에 따라 언제든지 다른 클래스로 `교체`할 수 있다는 것이다.
  - 단 교체하려면 인터페이스가 같거나 상속을 통한 부모 클래스가 같아서 `다형성`을 사용해야 한다. 
  - 불가능할 경우 `함수 옮기기`를 이용하여 인터페으스가 같아 질떄까지 필요한 동작들을 클래스 안으로 밀어 넣은 후 중복 코득 생기면 `슈퍼클래스 추출하기`를 적용할 지 고민 해보자.

### 데이터 클래스 (DTO)
- public 필드가 있다면 `레코드 캡슐화하기`를 통해 데이터를 캡슐화 해주자
- 변경하면 안 되는 필드는 `세터 제거하기`로 접근을 원천 봉쇄 해주자.
- 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해서 사용하자 

### 상속 포기
- 부모의 유산을 원치 않거나 수 많은 유산 중에서 관심 있는 몇개만 받고 끝내려는 경우에는 서브클래스에 필요한 메서드를 `메서드 내리기`와 `필드 내리기`  
  를 통하여 물려받고 싶지 않을 부모 코드를 서브 클래스로 내린 후 부모 클래스에는 공통 된 필드 및 메서드만 남겨두자
- 단! 서브 클래스가 부모의 동작은 `필요로 하지만` 인터페이스는 따르고 싶지 않을 때 문제이다.
  - 이럴 때는  `서브클래스 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용해서 아예 상속 메커니즘에서 벗어날 수 있다.

### 주석
- 주석은 악취가 아닌 향기를 입힌다.
- 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를 적용하거나 이미 추출 되어 있다면 `함수 선언 바꾸기`로 함수 이름을 바꿔보자
- 시스템이 동장하기 위한 선행 조건을 명시하고 싶다면 `어서션 추가하기`를 사용하자.
- `주성을 남겨야겠다는 생각이들면 , 가장 먼저 주석이 필요 없는 코드로 "리팩토링" 해보자!`
- 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석을 남기자.


<hr/>

## 테스트 구축

### 실패 해야할 상황을 만들자
- 실패 해야할 상황에서는 반드시 실패하게 만들어 주자
- 각각의 테스트가 실패하는 모습을 최소 한번 쯤은 실패할 수 있는 상황을 만들어서라도 테스트를 하자
  - 일부러 오류를 주입하는것이다.
- 자주 테스트하고, 작성 중인 코드는 최소 한 몇 분 간격으로 테스트하며 적어도 하루에 한번은 전체 테스트를 돌려보자

### 테스트 추가하기
- public 메서드를 `빠짐 없이 테스트 할 필요`는 없다.
  - 테스트는 `위험 요인을 중심`으로 작성해야한다.
  - `단순히 필드`를 읽고 쓰기만 하는 접근자는 테스트를 `할 필요가 없다.`s
    - 너무 단순한 코드는 버그가 숨어들 가능성이 별로 없기 떄문임
  - 테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽다.
    - 중요하거나 오류의 가능성이 큰 영역을 집중적으로 테스트하여  `테스트의 효과를 극대화 시키는 것이 중요하다.`
- 코드를 수정하여 임의의 값을 설정해서라도 테스트를 진행해주자.
  - 현재일 기준 전월을 구하는 날짜 로직에서 오늘 일자 기준으로만 구하는 로직이라면 일부로 날짜를 말일로 `코드를 임의로 변경하면` 생각하지 못한 예외를 찾을 수 있다  
  -> 현재 달의 -1인 로직이 오늘 날짜 기준 달을 -1만 한 후 날짜를 그대로 사용하면 일과 달이 안맞는 일이 생기는 경우가 있을 수 있다.
- 사용하는 데이터가 같다고 같은 테스트를 한 메서드에서 실행 시키면 좋지 않다.
  - 테스트끼리는 상호작용하는 공유 픽처스 사용하면 다른 테스트가 실패 할 확률도 있고 테스트의 실행 순서에 따라 결과가 달라질 수도 있으며 테스트 자체를 믿기 어려워진다.
```javscipt
// javascript
describe('province',function(){
  // 👎 좋지 못한 방법이다. 한개의 픽처스로 같이 두개의 테스트 진행 중
  const asia = new Province(siampleProvinceDate());
  
  it('shortfall',()=>{
    expect(asia.shortfall).equals(5);
  })
  
  it('profit',()=>{
    expect(asia.profit).equals(230);
  })
})
```

### 경계 조건 검사하기
- 순조로운 값만 들어온다 생각하는 테스트가 아닌 개발자가 생각한 의도를 벗어난 경계 지점의 테스트 또한 필요하다.
  - 필요한 테이터가 `null, 공백`이거나 문자열을 기대했지만 `숫자`가 들어 오는 경우 `음수`가 들어오는 경우 등등
- 위와 같이 경계를 확인 하는 테스트를 작성하다보면 프로그램에서 이런 특이 상황을 어떻게 처리하는 게 좋을지 생각해 볼 수 있다.
  - `문제가 생길 가능성이 있느 경계 조건을 생각해 보고 그 부분을 집중적으로 테스트하자`
  - `모든 버그를 잡아낼 수 는 없다고 생각하여 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.`
    - 많은 테스트는 오히려 프로그래밍을 속도와 개발 속도를 높혀 준다는 사실은 변함이 없다.
      - 단 여기서 중요한건 모든 기능을 테스트 하는것이 아닌 중요한 위험한 부분에 `집중`하여 테스트 하는 것이 중요하다.
- 테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩터링을 할 수 있는 `보호막`은 되어준다.